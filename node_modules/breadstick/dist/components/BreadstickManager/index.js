"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _animejs = _interopRequireDefault(require("animejs"));

var _Message = _interopRequireDefault(require("../Message"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var positions = {
  top: [],
  'top-left': [],
  'top-right': [],
  'bottom-left': [],
  bottom: [],
  'bottom-right': []
};
/**
 * @description Compute styles for specific position
 * @param {String} position
 * @returns {Object} Styles object
 */

var computeBreadstickStyle = function computeBreadstickStyle(position) {
  var style = {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center'
  };

  if (position.includes('right')) {
    style.alignItems = 'flex-end';
  } else if (position.includes('left')) {
    style.alignItems = 'flex-start';
  }

  return style;
};
/**
 * Breadstick Animations
 */


var animations = {
  enter: function enter(el) {
    var height = el.clientHeight;
    return {
      height: [0, height],
      opacity: [0, 1],
      scale: [0.9, 1]
    };
  },
  leave: {
    height: 0,
    opacity: [1, 0],
    scale: [1, 0.9]
  }
};
/**
 * Breadstick component
 */

var BreadstickManager = {
  name: 'BreadstickManager',
  data: function data() {
    return {
      idCounter: 0,
      positions: positions
    };
  },
  props: {
    notify: Function,
    default: function _default() {
      return null;
    }
  },
  created: function created() {
    this.notify(this._notify, this.closeAll);
  },
  methods: {
    /**
     * @description Creates toast state for single toast notification
     * @param {Object|Vue.Component|String} message
     * @param {Object} options
     * @returns {Object} Toast state object
     */
    createToastState: function createToastState(message, options) {
      var _this = this;

      var id = ++this.idCounter; // a bit messy, but object.position returns a number because
      // it's a method argument.

      var position = options.hasOwnProperty('position') && typeof options.position === 'string' ? options.position : 'top';
      return {
        id: id,
        message: message,
        position: position,
        showing: true,
        duration: typeof options.duration === 'undefined' ? 5000 : options.duration,
        onRequestRemove: function onRequestRemove() {
          return _this.removeToast(String(id), position);
        },
        type: options.type
      };
    },

    /**
     * @description Shows notification
     * @param {Object|Vue.Component|String} message
     * @param {Object} options
     */
    _notify: function _notify(message, options) {
      var toast = this.createToastState(message, options);
      var position = toast.position; // prepend the toast for toasts positioned at the top of
      // the screen, otherwise append it.

      var isTop = position.includes('top');
      isTop ? this.positions[position].unshift(toast) : this.positions[position].push(toast);
    },

    /**
     * @description Close all toast components
     */
    closeAll: function closeAll() {
      var _this2 = this;

      Object.keys(this.positions).forEach(function (pos) {
        var position = _this2.positions[pos];
        position.forEach(function (toast) {
          _this2.removeToast(toast.id, pos);
        });
      });
    },

    /**
     * @description Remove toast from position list
     * @param {String} id
     * @param {String} position
     */
    removeToast: function removeToast(id, position) {
      this.positions[position] = this.positions[position].filter(function (toast) {
        return toast.id !== id;
      });
      return this.positions[position];
    },

    /**
    * @description Compute styles for  toast component
    * @param {String} position
    */
    getStyle: function getStyle(position) {
      var style = {
        width: 'fit-content',
        position: 'fixed',
        zIndex: 5500
      };

      if (position === 'top' || position === 'bottom') {
        style.margin = '0 auto';
        style.textAlign = 'center';
      }

      if (position.includes('top')) {
        style.top = 0;
      }

      if (position.includes('bottom')) {
        style.bottom = 0;
      }

      if (!position.includes('left')) {
        style.right = 0;
      }

      if (!position.includes('right')) {
        style.left = 0;
      }

      return style;
    },

    /**
     * @description Get animation for transition
     * @param {String} key Type of animation phase
     * @param {HTMLElement} el Element
     */
    getAnimation: function getAnimation(key, el) {
      var animation = animations[key];
      return typeof animation === 'function' ? animation.call(this, el) : animation;
    },

    /**
     * @description Calls enter animation
     * @param {{el: HTMLElement, complete: Function}} el
     */
    enter: function enter(el, complete) {
      var animation = this.getAnimation('enter', el);
      (0, _animejs.default)(_objectSpread({
        targets: el
      }, animation, {
        complete: complete,
        easing: 'spring(1, 100, 50, 0)'
      }));
    },

    /**
     * @description Calls leave animation
     * @param {{el: HTMLElement, complete: Function}} el
     */
    leave: function leave(el, complete) {
      var animation = this.getAnimation('leave', el);
      (0, _animejs.default)(_objectSpread({
        targets: el
      }, animation, {
        complete: complete,
        easing: 'spring(1, 100, 70, 0)'
      }));
    }
  },
  render: function render(h) {
    var _this3 = this;

    return h('span', [Object.keys(this.positions).map(function (position) {
      var pos = position;
      var toasts = _this3.positions[pos];
      return h('TransitionGroup', {
        style: _this3.getStyle(pos),
        props: {
          css: false
        },
        on: {
          enter: _this3.enter,
          leave: _this3.leave
        },
        key: position,
        class: ['Breadstick__manager-' + pos],
        ref: "BreadstickManager_".concat(pos)
      }, [toasts.map(function (toast) {
        return h(_Message.default, {
          props: _objectSpread({
            position: pos,
            key: toast.id,
            message: toast.message
          }, toast),
          style: _objectSpread({}, computeBreadstickStyle(pos)),
          on: {
            remove: function remove(_ref) {
              var id = _ref.id,
                  position = _ref.position;

              _this3.removeToast(id, position);
            }
          },
          key: toast.id
        }, _this3.$slots.default);
      })]);
    })]);
  }
};
var _default2 = BreadstickManager;
exports.default = _default2;